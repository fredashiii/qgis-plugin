# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Smarty
                                 A QGIS plugin
 Smarty attempt
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Smarty
        email                : caroline@smarty.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QUrl, QUrlQuery
from qgis.PyQt.QtGui import QIcon, QColor
# from qgis.PyQt.QtNetwork import QtNetworkRequest
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QCompleter, QFileDialog, QApplication, QWidget, QVBoxLayout, QLineEdit, QGridLayout
# from qgis.core import QgsProject, Qgis
from qgis.core import (QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject, QgsApplication,
                       QgsRectangle, QgsPointXY, QgsGeometry, QgsVectorLayer, QgsCategorizedSymbolRenderer,
                       QgsFeature, QgsMarkerSymbol, QgsNetworkAccessManager, QgsNetworkReplyContent, Qgis, 
                       QgsPalLayerSettings, QgsTextFormat, QgsTextBackgroundSettings, QgsVectorLayerSimpleLabeling,
                       QgsVectorFileWriter, QgsCoordinateTransformContext, QgsLayerDefinition, QgsLayerTreeLayer, QgsMapLayer)

#########
from smartystreets_python_sdk import StaticCredentials, exceptions, ClientBuilder, SharedCredentials, StaticCredentials, Batch
from smartystreets_python_sdk.us_street import Lookup as StreetLookup
from smartystreets_python_sdk.us_autocomplete_pro import Lookup as AutocompleteProLookup, geolocation_type
#########

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .smarty_dialog import SmartyDialog
import os.path
import sys
import pandas as pd
import webbrowser


class Smarty:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        # import pip
        # pip._internal.main(['install', 'smartystreets_python_sdk'])
        # import subprocess
        # import sys
        # #subprocess.check_call([sys.executable, "-m", "pip", "install", "smartystreets_python_sdk"])
        # subprocess.call(['pip', 'install', 'smartystreets_python_sdk'])

        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Smarty_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Smarty')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Smarty', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/smarty/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Smarty'),
                action)
            self.iface.removeToolBarIcon(action)


    def smarty_single(self):
        ######################################################### build client and grab results
        auth_id = "c21cabd2-1a89-7746-e799-d35d70d7080b"
        auth_token = "nD3IIoyZ3H4LSzNp6qpl"

        credentials = StaticCredentials(auth_id, auth_token)

        client = ClientBuilder(credentials).with_licenses(["us-rooftop-geo"]).build_us_street_api_client()

        lookup = StreetLookup()
        lookup.match = "enhanced" 
        
        if len(self.dlg.single_address_lookup.text()) > 0:
            lookup.street = self.dlg.single_address_lookup.text()
        else:
            lookup.street = self.dlg.street.text() 
            lookup.city = self.dlg.city.text() 
            lookup.state = self.dlg.state.text() 
            lookup.zipcode = self.dlg.zipcode.text()
            lookup.candidates = 3

        try:
            client.send_lookup(lookup)
        except exceptions.SmartyException as err:
            self.iface.messageBar().pushMessage("FAIL: ", str(exceptions.SmartyException), level=Qgis.Critical, duration=6)
            return

        result = lookup.result

        if not result:
            self.iface.messageBar().pushMessage("NO MATCH: ", "See Summary section of results for more information.", level=Qgis.Critical, duration=6)
            return

        candidate = result[0]

        ############################################################################################################################

                                                            ######### CREATE VECTOR LAYER
        project = QgsProject.instance()

        if self.dlg.new_layer_radio.isChecked():
            layer_name = self.dlg.layer_name_single.text()
            
            if layer_name == "":
                layer_name = "Smarty"
            
            layer_out = QgsVectorLayer("Point?crs=EPSG:4326&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
            layer_name,
            "memory") 
        else:
            ########### TODO: I THINK WE NEED TO TAKE THE SELECTED LAYER, NOT CREATE A NEW ONE *PALM IN FACE
            layer_out = QgsVectorLayer("Point?crs=EPSG:4326&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
            "Smarty",
            "memory") 
        
        ############################################################################################################################

                                                            ######### SET RESULTS ON GUI
        
        # TODO: Put this in a function so it is not repeated -- do I really need to set it = to a variable? Address maybe, but the other ones not so much
        address = self.set_address(candidate)
        longitude = candidate.metadata.longitude
        latitude = candidate.metadata.latitude
        city = candidate.components.city_name
        state = candidate.components.state_abbreviation
        zip_code = candidate.components.zipcode
        zip_4 = candidate.components.plus4_code
        precision = candidate.metadata.precision
        county = candidate.metadata.county_name
        county_fips = candidate.metadata.county_fips
        rdi = candidate.metadata.rdi
        cong_dist = candidate.metadata.congressional_district
        time_zone = candidate.metadata.time_zone
        dst = candidate.metadata.obeys_dst 

        self.dlg.resize(627,586)
        self.dlg.results.setVisible(True)
        
        # Set up output of results
        self.dlg.address_result.setText(address)
        self.dlg.city_result.setText(city)
        self.dlg.state_result.setText(state)
        self.dlg.zip_result.setText(zip_code)
        self.dlg.zip_4_result.setText(zip_4)
        self.dlg.latitude_result.setText(str(latitude))
        self.dlg.longitude_result.setText(str(longitude))
        self.dlg.precision_result.setText(precision)

        # Set up output of Meta Data results
        self.dlg.county_name_result.setText(county)
        self.dlg.county_fips_result.setText(county_fips)
        self.dlg.rdi_result.setText(rdi)
        self.dlg.congressional_district_result.setText(cong_dist)
        self.dlg.time_zone_result.setText(time_zone)
        self.dlg.dst_result.setText(str(dst))

        ############################################################################################################################

                                                            ######### ADD LAT AND LONG

        point_out = QgsPointXY(longitude, latitude)
        feature = QgsFeature()
        feature.setGeometry(QgsGeometry.fromPointXY(point_out)) 

        if len(self.dlg.point_label.text()) == 0:
            label = address
        else:
            label = self.dlg.point_label.text() 

        feature.setAttributes([address, longitude, latitude, city, state, zip_code, zip_4, precision, county,
        county_fips, rdi, cong_dist, time_zone, dst, label])   

        symbol = self.set_symbol(self.dlg.symbol_color_single.color(), self.dlg.symbol_drop_down_single.currentText())
        
        layer_out.dataProvider().addFeature(feature)
        layer_out.renderer().setSymbol(symbol)

        layer_out = self.set_label(layer_out)

        layer_out.updateExtents()

        project.addMapLayer(layer_out)

        ############################################################################################################################

                                                            ######### ZOOM TO BOUNDING BOX 
        
        if self.dlg.zoom_in.isChecked(): 
            # convert coordinates
            crsSrc = QgsCoordinateReferenceSystem(4326)  # WGS84
            crsDest = QgsCoordinateReferenceSystem(QgsProject.instance().crs())
            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())
            # forward transformation: src -> dest
            center_point = xform.transform(point_out)
            self.iface.mapCanvas().setCenter(center_point)

            zoom = 18.75
            if zoom is not None:
                # transform the zoom level to scale
                scale_value = 591657550.5 / 2 ** (zoom - 1)
                self.iface.mapCanvas().zoomScale(scale_value)

        ############################################################################################################################  
        
        self.refresh_layers()

        layer_out.commitChanges()


    def smarty_batch(self):

        df = pd.read_csv(self.dlg.csv_file.filePath())
        
        address = self.dlg.batch_address.currentText()
        city = self.dlg.batch_city.currentText()
        state = self.dlg.batch_state.currentText()
        zip = self.dlg.batch_zip.currentText()

        add_df = df[[address, city, state, zip]].copy()

        project = QgsProject.instance()
        
        ##############################################################################################################################

        layer_name = self.dlg.layer_name.text()
        if layer_name == "":
            layer_name = "Smarty"
 
        layer_out = QgsVectorLayer("Point?crs=EPSG:4326&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string",
                layer_name,
                "memory") # TODO: can it exist disk

        ##############################################################################################################################
                        ######################### START SMARTY PROCESSING

        # Authentication
        auth_id = self.dlg.auth_id.text() # "c21cabd2-1a89-7746-e799-d35d70d7080b" #
        auth_token = self.dlg.auth_token.text() # "nD3IIoyZ3H4LSzNp6qpl" #
        credentials = StaticCredentials(auth_id, auth_token)

        # Build client
        client = ClientBuilder(credentials).with_licenses(["us-rooftop-geo"]).build_us_street_api_client()
        batch = Batch()

        ###############################################################################################################################
        
        for i, row in add_df.iterrows():

            #TODO: After the first iteration add a check for a 401 error --> means they dont have correct credentials
            full_address = row[address] + " " + row[city] + " " + row[state] + " " + str(row[zip])
           
            # street = row['address']
            # city = row['city']
            # state = row['state']
            # zipcode = str(row['zip'])

            batch.add(StreetLookup(full_address))
            batch[i].match = 'enhanced'

        try:
            client.send_batch(batch)
        except exceptions.SmartyException as err:
            self.iface.messageBar().pushMessage("FAIL: ", "LOOK UP FAILED", level=Qgis.Critical, duration=6)
            return

        # if not result:
        #     self.iface.messageBar().pushMessage("NO MATCH: ", "NO RESULTS RETURNED", level=Qgis.Critical, duration=6)
        #     continue # return
        #     # FIXME: you need to think about appending a list of addresses that invalid addresses

        ##################################################################################################################################
                            ######################## ITERATE OVER RESULTS
        for i, lookup in enumerate(batch):

            candidates = lookup.result

            for candidate in candidates:

                longitude = candidate.metadata.longitude
                latitude = candidate.metadata.latitude

                address = self.set_address(candidate)
                longitude = candidate.metadata.longitude
                latitude = candidate.metadata.latitude
                city = candidate.components.city_name
                state = candidate.components.state_abbreviation
                zip_code = candidate.components.zipcode
                zip_4 = candidate.components.plus4_code
                precision = candidate.metadata.precision
                county = candidate.metadata.county_name
                county_fips = candidate.metadata.county_fips
                rdi = candidate.metadata.rdi
                cong_dist = candidate.metadata.congressional_district
                time_zone = candidate.metadata.time_zone
                dst = candidate.metadata.obeys_dst

                point_out = QgsPointXY(longitude, latitude)
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPointXY(point_out))
            
            ###########################################################
                feature.setAttributes([address, longitude, latitude, city, state, zip_code, zip_4, precision, county,
                            county_fips, rdi, cong_dist, time_zone, dst])

                symbol = self.set_symbol(self.dlg.symbol_color.color(), self.dlg.symbol_drop_down.currentText())
                
                layer_out.dataProvider().addFeature(feature)
                layer_out.renderer().setSymbol(symbol)
                
                layer_out.updateExtents()
        
        project.addMapLayer(layer_out)

            # TODO: output a list of the validated and non validated addresses?

    def smarty_geo_link(self):
        webbrowser.open("https://www.smarty.com/pricing/us-rooftop-geocoding")
    
    def smarty_home_link(self):
        webbrowser.open("https://www.smarty.com/products/us-rooftop-geocoding")

    def set_symbol(self, color, symbol):
        symbol = QgsMarkerSymbol.createSimple({'name': symbol, 'color': color, 'outline_color': '35,35,35,255', 'outline_style': 'solid', 'size':'8'})

        return symbol
    
    def enable_box(self):
        auth_id_len = len(self.dlg.auth_id.text())
        auth_token_len = len(self.dlg.auth_token.text())
        
        if auth_id_len == 0 and auth_token_len == 0:
            self.iface.messageBar().pushMessage("FAIL: ", "Please add an Auth ID and an Auth Token", level=Qgis.Critical, duration=6)
            return
        elif auth_id_len == 0:
            self.iface.messageBar().pushMessage("FAIL: ", "Please add an Auth ID", level=Qgis.Critical, duration=6)
            return
        elif auth_token_len == 0:
            self.iface.messageBar().pushMessage("FAIL: ", "Please add an Auth Token", level=Qgis.Critical, duration=6)
            return
        
        self.dlg.frame.setEnabled(True)
    
    def meta_resize(self):
        if self.dlg.meta_data.isChecked():
            self.dlg.resize(627,712)
            self.dlg.meta_data_results.setVisible(True)
        else:
            self.dlg.resize(627,586)
            self.dlg.meta_data_results.setVisible(False)
    
    def refresh_layers(self):
        layers = QgsProject.instance().layerTreeRoot().children()

        layers_list = []

        layers = QgsProject.instance().mapLayers().values()

        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                layers_list.append( layer )

        self.dlg.layer_box.clear()
        self.dlg.layer_box.addItems([layer.name() for layer in layers_list])
    
    def fill_symbols(self):
        # TODO: gather all the output options --> the equilateral_triangle and regular_star is kind of sketchy...

        # for cat in renderer.categories(): ############# RENDERER NOT DEFINED
        #     # print("{}: {} :: {}".format(cat.value(), cat.label(), cat.symbol()))

        symbols = ['star', 'regular_star', 'square', 'cross', 'rectangle', 'diamond', 'pentagon', 'triangle', 'equilateral_triangle', 'circle', 'arrow', 'filled_arrowhead', 'x']

        self.dlg.symbol_drop_down.addItems(symbol for symbol in symbols)
        self.dlg.symbol_drop_down_single.addItems(symbol for symbol in symbols)

    def show_new_layer(self):
        self.dlg.stacked_widget.setCurrentIndex(0)
        self.dlg.stacked_widget.setVisible(True)

        self.dlg.new_layer_frame.setDisabled(False)
        self.dlg.new_layer_frame.setVisible(True)

    def show_existing_layer(self):
        self.dlg.stacked_widget.setVisible(True)
        self.dlg.stacked_widget.setCurrentIndex(1)
        
        self.dlg.existing_layer_frame.setVisible(True)
        self.dlg.existing_layer_frame.setDisabled(False)
    
    def set_label(self, layer_out):
        label_settings = QgsPalLayerSettings()

        label_settings.displayAll = True

        if len(self.dlg.point_label.text()) == 0:
            label_settings.fieldName = 'address'
        else:
            label_settings.fieldName = 'label'

        text_format = QgsTextFormat()
        background_color = QgsTextBackgroundSettings()
        background_color.setFillColor(QColor('white'))
        background_color.setEnabled(True)
        text_format.setBackground(background_color )
        text_format.setSize(19)
        label_settings.setFormat(text_format)

        layer_out.setLabeling(QgsVectorLayerSimpleLabeling(label_settings))
        layer_out.setLabelsEnabled(True)
        layer_out.triggerRepaint()

        return layer_out
    
    def autocomplete(self):
        text = self.dlg.autocomplete.text()
        
        if len(text) > 0 :

            key = "90464575666784311"
            hostname = "qgis"

            credentials = SharedCredentials(key, hostname)

            client = ClientBuilder(credentials).with_licenses(["us-autocomplete-pro-cloud"]).build_us_autocomplete_pro_api_client()
            
            lookup = AutocompleteProLookup(text) 
            
            client.send(lookup) 

            suggestion_list = []
            for suggestion in lookup.result:
                address = suggestion.street_line + " " + suggestion.secondary + " " + suggestion.city + " " + suggestion.state + " " + suggestion.zipcode
                suggestion_list.append(address)

            # Set completer object and connect it to the lineEdit
            completer = QCompleter(suggestion_list, caseSensitivity=QtCore.Qt.CaseInsensitive)
            self.dlg.autocomplete.setCompleter(completer)

            self.dlg.autocomplete.show()

            # TODO: MAYBE FIGURE OUT HOW TO DO THE FILTERING?
    
    def set_address(self, candidate):
        address = ''
        if candidate.components.primary_number is not None:
            address = address + candidate.components.primary_number
        if candidate.components.street_predirection is not None:
            address = address + candidate.components.street_predirection
        if candidate.components.street_name is not None:
            address = address + candidate.components.street_name
        if candidate.components.street_postdirection is not None:
            address = address + candidate.components.street_postdirection
        
        return address
    
    def resize_dialog(self):
        if self.dlg.tabWidget.currentIndex() == 0:
            self.dlg.resize(627,519)
        else:
            self.dlg.resize(627,390)
    
    def add_csv(self):
        df = pd.read_csv(self.dlg.csv_file.filePath())
        
        fields = df.columns.values.tolist()

        self.dlg.batch_address.addItems(field for field in fields)
        self.dlg.batch_city.addItems(field for field in fields)
        self.dlg.batch_state.addItems(field for field in fields)
        self.dlg.batch_zip.addItems(field for field in fields)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SmartyDialog()
            
            # Listen for clicked buttons
            self.dlg.pushButton.clicked.connect(self.smarty_single)
            self.dlg.batch_button.clicked.connect(self.smarty_batch)
            self.dlg.smarty_link_1.clicked.connect(self.smarty_home_link)
            self.dlg.smarty_link_2.clicked.connect(self.smarty_geo_link)
            self.dlg.add_tokens.clicked.connect(self.enable_box)
            self.dlg.meta_data.clicked.connect(self.meta_resize)
            self.dlg.new_layer_radio.clicked.connect(self.show_new_layer)
            self.dlg.existing_layer_radio.clicked.connect(self.show_existing_layer)

            #TODO: DISABLE BUTTON UNTIL CSV IS CHOSEN - THEN MAYBE CONSIDER DOING ERROR HANDLING
            self.dlg.add_csv.clicked.connect(self.add_csv)

            # Disable sections of dialogue box
            self.dlg.frame.setDisabled(True)

            # Fill drop downs
            self.refresh_layers()
            self.fill_symbols()

            # Set correct visibility
            self.dlg.meta_data_results.setVisible(False)
            self.dlg.results.setVisible(False)
            self.dlg.stacked_widget.setVisible(False)

            # Autocompleter listener
            self.dlg.autocomplete.textChanged.connect(self.autocomplete)
            # self.dlg.single_address_lookup.textChanged.connect(self.autocomplete)

            # Resize Dialog box for batch lookups
            self.dlg.tabWidget.tabBarClicked.connect(self.resize_dialog)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
