# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Smarty
                                 A QGIS plugin
 Smarty attempt
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Smarty
        email                : caroline@smarty.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from calendar import c
from itertools import count
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QUrl, QTimer
from qgis.PyQt.QtGui import QIcon, QColor, QStandardItemModel, QStandardItem
# from qgis.PyQt.QtNetwork import QtNetworkRequest
from qgis.PyQt.QtWidgets import QAction, QCompleter, QTabWidget
# from qgis.core import QgsProject, Qgis
from qgis.core import (QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject, QgsApplication,
                       QgsRectangle, QgsPointXY, QgsGeometry, QgsVectorLayer, QgsCategorizedSymbolRenderer,
                       QgsFeature, QgsMarkerSymbol, QgsNetworkAccessManager, QgsNetworkReplyContent, Qgis, 
                       QgsPalLayerSettings, QgsTextFormat, QgsTextBackgroundSettings, QgsVectorLayerSimpleLabeling,
                        QgsMapLayer)

#########
from smartystreets_python_sdk import StaticCredentials, exceptions, ClientBuilder, SharedCredentials, StaticCredentials, Batch
from smartystreets_python_sdk.us_street import Lookup as StreetLookup
from smartystreets_python_sdk.us_autocomplete_pro import Lookup as AutocompleteProLookup, geolocation_type
#########

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .smarty_dialog import SmartyDialog, SaveDialog
from .utils import Utils
import os.path
import sys
import pandas as pd
import webbrowser
import csv
import time
# import thread

    
class c(QCompleter):

    def __init__(self, smarty, parent=None):
        super().__init__(parent)
        self.smarty = smarty
        self.text = ''

    def pathFromIndex(self, index): # So an idea is to piggy back off the textedited event
        self.text = str(index.data(role=2))
        
        if self.text.find('entries') != -1: 
            found = found = self.text.find('(')
            QTimer.singleShot(0, self.auto)
        
        return str(self.text[:found])
    
    def auto(self):
        key = "90464575666784311"
        hostname = "qgis"

        credentials = SharedCredentials(key, hostname)

        client = ClientBuilder(credentials).with_licenses(["us-autocomplete-pro-cloud"]).build_us_autocomplete_pro_api_client()
        self.smarty.iface.messageBar().pushMessage("We selected an address ", self.text, level=Qgis.Critical, duration=6)
        
        # Set up api call
        found = self.text.find('(')
        search = self.text.replace(' entries)', ')')
        lookup = AutocompleteProLookup()
        lookup.search = self.text[:found]
        lookup.selected = search
        
        # QTimer.singleShot(0, self.timer) --> send it a function that it can call
        
        client.send(lookup) 

        # get suggestions
        suggestion_list = []
        for suggestion in lookup.result:

            address = suggestion.street_line + " " + suggestion.secondary + " " + suggestion.city + " " + suggestion.state + " " + suggestion.zipcode
            suggestion_list.append(address)

        # Set completer object and connect it to the lineEdit
        self.smarty.autocomplete_model = QStandardItemModel()
        for text in suggestion_list:
            self.smarty.autocomplete_model.appendRow(QStandardItem(text))

        self.smarty.completer.setModel(self.smarty.autocomplete_model)
        self.smarty.dlg.single_address_lookup.setCompleter(self.smarty.completer)
        
        return

class Smarty:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        # import pip
        # pip._internal.main(['install', 'smartystreets_python_sdk'])
        # import subprocess
        # import sys
        # #subprocess.check_call([sys.executable, "-m", "pip", "install", "smartystreets_python_sdk"])
        # subprocess.call(['pip', 'install', 'smartystreets_python_sdk'])

        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # I added this... 

        # self.completer = QCompleter(caseSensitivity=QtCore.Qt.CaseInsensitive)
        self.completer = QCompleter(caseSensitivity=QtCore.Qt.CaseInsensitive)
        self.completer.setCompletionMode(QCompleter.UnfilteredPopupCompletion)
        self.completer.setMaxVisibleItems(100)

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Smarty_{}.qm'.format(locale))
        
        self.settings = QSettings()
        self.counter2 = 0

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Smarty')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Smarty', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/smarty/smarty-icon-gradient.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Smarty'),
                action)
            self.iface.removeToolBarIcon(action)

    def smarty_single(self):
        self.dlg.meta_data.setChecked(False)

        auth_id = "c21cabd2-1a89-7746-e799-d35d70d7080b"
        auth_token = "nD3IIoyZ3H4LSzNp6qpl"

        credentials = StaticCredentials(auth_id, auth_token)

        client = ClientBuilder(credentials).with_licenses(["us-rooftop-geo"]).build_us_street_api_client()

        lookup = StreetLookup()
        lookup.match = "enhanced" 
        
        if self.dlg.tabWidget_2.currentIndex() == 1:
            if not len(self.dlg.street.text()) > 0:
                self.iface.messageBar().pushMessage("ERROR ", "Please add an address" , level=Qgis.Critical, duration=6)
                return
            lookup.street = self.dlg.street.text() 
            lookup.city = self.dlg.city.text() 
            lookup.state = self.dlg.state.text() 
            lookup.zipcode = self.dlg.zipcode.text()
            lookup.candidates = 3
        else:
            if not len(self.dlg.single_address_lookup.text()) > 0:
                self.iface.messageBar().pushMessage("ERROR ", "Please add an address" , level=Qgis.Critical, duration=6)
                return
            lookup.street = self.dlg.single_address_lookup.text()
        
        try:
            client.send_lookup(lookup)
        except exceptions.SmartyException as err:
            self.iface.messageBar().pushMessage("FAIL: ", str(exceptions.SmartyException), level=Qgis.Critical, duration=6)
            return

        result = lookup.result

        success = Utils.handle_success(result)

        if success == "No Match. The address is invalid.":
            self.dlg.resize(586, 532)
            self.dlg.results.setVisible(True)
            self.dlg.summary_result.setText(success)
            self.iface.messageBar().pushMessage("NO MATCH: ", "See Summary section of results for more information.", level=Qgis.Critical, duration=6)
            return

        candidate = result[0]

        ############################################################################################################################

                                                            ######### CREATE VECTOR LAYER
        project = QgsProject.instance()

        if self.dlg.new_layer_radio.isChecked() == False and self.dlg.existing_layer_radio.isChecked() == False:
            layer_out = QgsVectorLayer("Point?crs=EPSG:4326&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
            'Smarty',
            "memory") 

        elif self.dlg.new_layer_radio.isChecked():
            layer_name = self.dlg.layer_name_single.text()
            
            if layer_name == "":
                layer_name = "Smarty"
            
            layer_out = QgsVectorLayer("Point?crs=EPSG:4326&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
            layer_name,
            "memory") 

        elif self.dlg.existing_layer_radio.isChecked():
            layers = self.refresh_layers()
            layer_out = layers[self.dlg.layer_box.currentIndex()] 
 
        self.refresh_layers()
        
        ############################################################################################################################

                                                            ######### SET RESULTS ON GUI
        
        address = self.set_address(candidate)
        longitude = candidate.metadata.longitude
        latitude = candidate.metadata.latitude
        city = candidate.components.city_name
        state = candidate.components.state_abbreviation
        zip_code = candidate.components.zipcode
        zip_4 = candidate.components.plus4_code
        precision = candidate.metadata.precision
        county = candidate.metadata.county_name
        county_fips = candidate.metadata.county_fips
        rdi = candidate.metadata.rdi
        cong_dist = candidate.metadata.congressional_district
        time_zone = candidate.metadata.time_zone
        dst = candidate.metadata.obeys_dst 

        self.dlg.resize(586,777)
        self.dlg.results.setVisible(True)
        
        # Set up output of results
        self.dlg.address_result.setText(address)
        self.dlg.city_result.setText(city)
        self.dlg.state_result.setText(state)
        self.dlg.zip_result.setText(zip_code)
        self.dlg.zip_4_result.setText(zip_4)
        self.dlg.latitude_result.setText(str(latitude))
        self.dlg.longitude_result.setText(str(longitude))
        self.dlg.precision_result.setText(precision)

        # Set up output of Meta Data results
        self.dlg.county_name_result.setText(county)
        self.dlg.county_fips_result.setText(county_fips)
        self.dlg.rdi_result.setText(rdi)
        self.dlg.congressional_district_result.setText(cong_dist)
        self.dlg.time_zone_result.setText(time_zone)
        self.dlg.dst_result.setText(str(dst))
        self.dlg.summary_result.setText(success)

        ############################################################################################################################

                                                            ######### ADD LAT AND LONG

        point_out = QgsPointXY(longitude, latitude)
        feature = QgsFeature()
        feature.setGeometry(QgsGeometry.fromPointXY(point_out)) 

        if len(self.dlg.point_label.text()) == 0:
            label = ''
        else:
            label = self.dlg.point_label.text() 

        feature.setAttributes([address, longitude, latitude, city, state, zip_code, zip_4, precision, county,
        county_fips, rdi, cong_dist, time_zone, dst, label])   

        symbol = self.set_symbol(self.dlg.symbol_color_single.color(), self.dlg.symbol_drop_down_single.currentText(), self.dlg.symbol_size_single.value())
        
        layer_out.dataProvider().addFeature(feature)
        layer_out.renderer().setSymbol(symbol)

        if label != '':
            layer_out = self.set_label_single(layer_out)

        layer_out.updateExtents()

        project.addMapLayer(layer_out)

        ################################################################################################       ZOOM TO BOUNDING BOX:
        
        if self.dlg.zoom_in.isChecked(): 
            # convert coordinates
            crsSrc = QgsCoordinateReferenceSystem(4326)  # WGS84
            crsDest = QgsCoordinateReferenceSystem(QgsProject.instance().crs())
            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())
            # forward transformation: src -> dest
            center_point = xform.transform(point_out)
            self.iface.mapCanvas().setCenter(center_point)

            zoom = 18.75
            if zoom is not None:
                # transform the zoom level to scale
                scale_value = 591657550.5 / 2 ** (zoom - 1)
                self.iface.mapCanvas().zoomScale(scale_value)

        ############################################################################################################################  
        
        self.refresh_layers()

        layer_out.commitChanges()

        self.dlg.point_label.setText('')

    def smarty_batch(self):
        # start = time.time()
        
        if self.dlg.csv_file_output.filePath() == '':
            self.iface.messageBar().pushMessage("Error: ", "Please select an output file", level=Qgis.Critical, duration=6)
            return
        elif self.dlg.csv_file.filePath() == '':
            self.iface.messageBar().pushMessage("Error: ", "Please select a CSV file to process", level=Qgis.Critical, duration=6)
            return

        df = pd.read_csv(self.dlg.csv_file.filePath())

        if self.dlg.id_box.isChecked():
            id_column_name = self.dlg.batch_id.currentText()
        else:
            id_column_name = 'ID'
            df.insert(0,'ID',range(0,0 + len(df))) # TODO THIS IS NOT WORKING... THERE IS PROBABLY A BETTER WAY TO DO THIS WITH THE LOOPS WE ALREADY HAVE?

        address = self.dlg.batch_address.currentText()
        city = self.dlg.batch_city.currentText()
        state = self.dlg.batch_state.currentText()
        zip = self.dlg.batch_zip.currentText()

        add_df = df[[id_column_name, address, city, state, zip]].copy()

        project = QgsProject.instance()
        
        ##############################################################################################################################

        if self.dlg.layer_name_batch.text() == '':
            layer_out = QgsVectorLayer("Point?crs=EPSG:4326&field=id:string&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
            'Smarty',
            "memory") 
        else:
            layer_out = QgsVectorLayer("Point?crs=EPSG:4326&field=id:string&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
            self.dlg.layer_name_batch.text(),
            "memory") 
        # else:
        #     layers = self.refresh_layers()
        #     layer_out = layers[self.dlg.layer_box_batch.currentIndex()] 


        ####################################################################################################     START SMARTY PROCESSING:

        # Authentication
        auth_id = self.dlg.auth_id.text() # "c21cabd2-1a89-7746-e799-d35d70d7080b" #
        auth_token = self.dlg.auth_token.text() # "nD3IIoyZ3H4LSzNp6qpl" #

        credentials = StaticCredentials(auth_id, auth_token)

        client = ClientBuilder(credentials).with_licenses(["us-rooftop-geo"]).build_us_street_api_client()
        batch = Batch()

        counter = 0
        for _, row in add_df.iterrows():
            batch.add(StreetLookup())
            batch[counter].street = row[address] # so on the 101th round it is trying to put the address in the batch?
            batch[counter].city = row[city]
            batch[counter].state = row[state] 
            batch[counter].zipcode = str(row[zip])# TODO: MAYBE MAKE A CHECK TO SEE IF THE COLUMN IS NUMERIC? DOES THIS EVEN MATTER?
            batch[counter].match = 'enhanced'

            counter += 1
            
            if batch.is_full():
                self.process_batch(df, id_column_name, layer_out, client, batch, self.counter2)
                batch.clear()
                counter = 0
        
        if len(batch) != 0:
            self.process_batch(df, id_column_name, layer_out, client, batch, self.counter2)
        
        project.addMapLayer(layer_out)
        self.output_csv(layer_out)

        self.refresh_layers()

        # end = time.time()
        # batch_time = (end - start)

    def process_batch(self, df, id_column_name, layer_out, client, batch, counter2):
        try:
            client.send_batch(batch)
        except exceptions.SmartyException as err: # check for a 401 error --> means they dont have correct credentials
            self.iface.messageBar().pushMessage("Error: ", str(err), level=Qgis.Critical, duration=6)
            return
                
        non_validated = []
        for i, lookup in enumerate(batch):
            candidates = lookup.result

            if len(candidates) == 0:
                self.iface.messageBar().pushMessage("NO MATCH FOR ADDRESS #: ", str(i), level=Qgis.Critical, duration=6)
                non_validated.append(lookup) # TODO: What should I do with these addresses? Maybe we think about setting the attributes with nulls and what they originally gave us?
                continue
                    
            candidates = lookup.result
            candidate = candidates[0]

            longitude = candidate.metadata.longitude
            latitude = candidate.metadata.latitude
            address_result = self.set_address(candidate)
            longitude = candidate.metadata.longitude
            latitude = candidate.metadata.latitude

            city_result = candidate.components.city_name
            state_result = candidate.components.state_abbreviation
            zip_result = candidate.components.zipcode
            zip_4 = candidate.components.plus4_code

            precision = candidate.metadata.precision
            county = candidate.metadata.county_name
            county_fips = candidate.metadata.county_fips
            rdi = candidate.metadata.rdi
            cong_dist = candidate.metadata.congressional_district
            time_zone = candidate.metadata.time_zone
            dst = candidate.metadata.obeys_dst

            point_out = QgsPointXY(longitude, latitude)
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPointXY(point_out))

            if self.dlg.batch_point_label.currentText() == 'None':
                label = ''
            else:
                label = str(df.at[i,self.dlg.batch_point_label.currentText()])
                layer_out = self.set_label_batch(layer_out)

            if self.dlg.id_box.isChecked() == False:
                self.counter2 += 1 
                id = self.counter2
            else: 
                id = str(df.at[i,id_column_name])

            feature.setAttributes([id, address_result, longitude, latitude, city_result, state_result, zip_result, zip_4, precision, county,
                            county_fips, rdi, cong_dist, time_zone, dst, label])

            symbol = self.set_symbol(self.dlg.symbol_color.color(), self.dlg.symbol_drop_down.currentText(), self.dlg.symbol_size_batch.value())
                    
            layer_out.dataProvider().addFeature(feature)
            layer_out.renderer().setSymbol(symbol)
                    
            layer_out.updateExtents()
        return layer_out
        
        # TODO: output a list of the validated and non validated addresses?

    def smarty_geo_link(self):
        webbrowser.open("https://www.smarty.com/pricing/us-rooftop-geocoding")
    
    def smarty_home_link(self):
        webbrowser.open("https://www.smarty.com/products/us-rooftop-geocoding")

    def smarty_help_link(self):
        webbrowser.open("https://www.smarty.com/docs/sdk/python")

    def set_symbol(self, color, symbol, size):
        if size == 0:
            size = '10'

        symbol = QgsMarkerSymbol.createSimple({'name': symbol, 'color': color, 'outline_color': '35,35,35,255', 'outline_style': 'solid', 'size':size})

        return symbol
    
    def add_tokens(self): ## FIXME: THIS IS DISABLED SO THAT IT DOESN'T TAKE 5EVER TO TEST

        self.settings.setValue("auth_id", self.dlg.auth_id.text())
        self.settings.setValue("auth_token", self.dlg.auth_token.text())

        auth_id_len = len(self.dlg.auth_id.text())
        auth_token_len = len(self.dlg.auth_token.text())
        
        if auth_id_len == 0 and auth_token_len == 0:
            self.iface.messageBar().pushMessage("FAIL: ", "Please add an Auth ID and an Auth Token", level=Qgis.Critical, duration=6)
            return
        elif auth_id_len == 0:
            self.iface.messageBar().pushMessage("FAIL: ", "Please add an Auth ID", level=Qgis.Critical, duration=6)
            return
        elif auth_token_len == 0:
            self.iface.messageBar().pushMessage("FAIL: ", "Please add an Auth Token", level=Qgis.Critical, duration=6)
            return
        
        # credentials = StaticCredentials(self.dlg.auth_id.text() , self.dlg.auth_token.text()) ######## This takes soooo long
        # client = ClientBuilder(credentials).with_licenses(["us-rooftop-geo"]).build_us_street_api_client()
        # lookup = StreetLookup()
        # lookup.street = ""

        # try:
        #     client.send_lookup(lookup)
        # except exceptions.SmartyException as err: # check for a 401 error --> means they dont have correct credentials
        #     message = str(err)
        #     self.iface.messageBar().pushMessage("Error: ", message, level=Qgis.Critical, duration=6)
        #     return

        self.dlg.frame.setEnabled(True)
    
    def meta_resize(self):
        if self.dlg.meta_data.isChecked():
            self.dlg.resize(586,998)
            self.dlg.meta_data_results.setVisible(True)
        else:
            self.dlg.resize(586,777)
            self.dlg.meta_data_results.setVisible(False)
    
    def refresh_layers(self):
        layers = QgsProject.instance().layerTreeRoot().children()

        layers_list = []

        layers = QgsProject.instance().mapLayers().values()

        for layer in layers: 
            if layer.type() == QgsMapLayer.VectorLayer: # you can also compare layer.type() == 0 (means it's a vectorlayer)
                
                attributeTableConfig = layer.attributeTableConfig()

                # TODO: this might not work... it would probably throw an error... maybe we just set id to 0 for single?
                # this is for the batch ones... it has an ID on it
                temp_layer = QgsVectorLayer("Point?crs=EPSG:4326&field=id:string&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
                "Smarty",
                "memory") 
                temp_attributeTableConfig = temp_layer.attributeTableConfig()

                # this is for the single lookups... it does not have an ID on it... 
                temp_layer2 = QgsVectorLayer("Point?crs=EPSG:4326&field=address:string&field=longitude:string&field=latitude:string&field=city:string&field=state:string&field=zip_code:string&field=zip_4:string&field=precision:string&field=county:string&field=county_fips:string&field=rdi:string&field=cong_dist:string&field=time_zone:string&field=dst:string&field=label:string",
                "Smarty",
                "memory") 
                temp_attributeTableConfig2 = temp_layer2.attributeTableConfig()

                if attributeTableConfig.hasSameColumns(temp_attributeTableConfig):
                    layers_list.append(layer)

                elif attributeTableConfig.hasSameColumns(temp_attributeTableConfig2):
                    layers_list.append( layer )

        self.dlg.layer_box.clear()
        self.dlg.layer_box.addItems([layer.name() for layer in layers_list])

        # self.dlg.layer_box_batch.clear()
        # self.dlg.layer_box_batch.addItems([layer.name() for layer in layers_list])

        return layers_list
    
    def fill_symbols(self):
        # TODO: gather all the output options in a civilized manner
        symbols = ['star', 'regular_star', 'square', 'cross', 'rectangle', 'diamond', 'pentagon', 'triangle', 'equilateral_triangle', 'circle', 'arrow', 'filled_arrowhead', 'x']

        self.dlg.symbol_drop_down.addItems(symbol for symbol in symbols)
        self.dlg.symbol_drop_down_single.addItems(symbol for symbol in symbols)

    def show_new_layer(self):
        self.dlg.stacked_widget.setCurrentIndex(0)
        self.dlg.stacked_widget.setVisible(True)

        self.dlg.new_layer_frame.setDisabled(False)
        self.dlg.new_layer_frame.setVisible(True)
    
    # def show_new_layer_batch(self):
    #     self.dlg.stacked_widget_batch.setCurrentIndex(0)
    #     self.dlg.stacked_widget_batch.setVisible(True)

    #     self.dlg.new_layer_frame_batch.setDisabled(False)
    #     self.dlg.new_layer_frame_batch.setVisible(True)

    def show_existing_layer(self):
        self.dlg.stacked_widget.setVisible(True)
        self.dlg.stacked_widget.setCurrentIndex(1)
        
        self.dlg.existing_layer_frame.setVisible(True)
        self.dlg.existing_layer_frame.setDisabled(False)

    # def show_existing_layer_batch(self):
    #     self.dlg.stacked_widget_batch.setVisible(True)
    #     self.dlg.stacked_widget_batch.setCurrentIndex(1)
        
    #     self.dlg.existing_layer_frame_batch.setVisible(True)
    #     self.dlg.existing_layer_frame_batch.setDisabled(False)
    
    def set_label_single(self, layer_out):
        label_settings = QgsPalLayerSettings()

        label_settings.displayAll = True

        if len(self.dlg.point_label.text()) == 0:
            label_settings.fieldName = 'address'
        else:
            label_settings.fieldName = 'label'

        text_format = QgsTextFormat()
        background_color = QgsTextBackgroundSettings()
        background_color.setFillColor(QColor('white'))
        background_color.setEnabled(True)
        text_format.setBackground(background_color )
        text_format.setSize(15)
        label_settings.setFormat(text_format)
        label_settings.placement = 1
        label_settings.quadOffset = 7
        label_settings.xOffset = 3
        label_settings.yOffset = 7

        layer_out.setLabeling(QgsVectorLayerSimpleLabeling(label_settings))
        layer_out.setLabelsEnabled(True)
        layer_out.triggerRepaint()

        return layer_out

    def set_label_batch(self, layer_out):
        # If they have chosen 'None' then we wont set any labels. -- > we could also do this for the batch with the ID?
        if self.dlg.batch_point_label.currentIndex == 1:
            return 
        label_settings = QgsPalLayerSettings()

        label_settings.displayAll = True

        label_settings.fieldName = 'label'

        text_format = QgsTextFormat()
        background_color = QgsTextBackgroundSettings()
        background_color.setFillColor(QColor('white'))
        background_color.setEnabled(True)
        text_format.setBackground(background_color)
        text_format.setSize(10)
        label_settings.setFormat(text_format)

        layer_out.setLabeling(QgsVectorLayerSimpleLabeling(label_settings))
        layer_out.setLabelsEnabled(True)
        layer_out.triggerRepaint()

        return layer_out
    
    def autocomplete(self):
        key = "90464575666784311"
        hostname = "qgis"

        credentials = SharedCredentials(key, hostname)

        client = ClientBuilder(credentials).with_licenses(["us-autocomplete-pro-cloud"]).build_us_autocomplete_pro_api_client()
        text = self.dlg.single_address_lookup.text()

        if text.find('entries') != -1: 
            self.autocomplete_apt()
        
        if len(text) > 0 :
            
            lookup = AutocompleteProLookup(text) 
            
            client.send(lookup) 

            suggestion_list = []
            for suggestion in lookup.result:

                if suggestion.entries != 0:
                    entry = ' (' + str(suggestion.entries) + ' entries)'
                else:
                    entry = ''
                address = suggestion.street_line + " " + suggestion.secondary + entry + " " + suggestion.city + " " + suggestion.state + " " + suggestion.zipcode
                suggestion_list.append(address)

                # if len(suggestion_list) == 5: # or use setMaxVisibleItems to 5
                #     break

            self.autocomplete_model = QStandardItemModel()
            for text in suggestion_list:
                self.autocomplete_model.appendRow(QStandardItem(text))

            self.completer.setModel(self.autocomplete_model)
            self.dlg.single_address_lookup.setCompleter(self.completer)

            # Set completer object and connect it to the lineEdit
        else:
            return
    
    def autocomplete_apt(self):
        # self.iface.messageBar().pushMessage("We selected an address ", "and got into the function", level=Qgis.Critical, duration=6)
        key = "90464575666784311"
        hostname = "qgis"

        credentials = SharedCredentials(key, hostname)

        client = ClientBuilder(credentials).with_licenses(["us-autocomplete-pro-cloud"]).build_us_autocomplete_pro_api_client()
        text = self.dlg.single_address_lookup.text()

        if text.find('entries') != -1: 
            
            found = text.find('(')
            search = text.replace(' entries)', ')')
            lookup = AutocompleteProLookup()
            lookup.search = text[:found]
            lookup.selected = search
            
            client.send(lookup) 

            suggestion_list = []
            for suggestion in lookup.result:

                address = suggestion.street_line + " " + suggestion.secondary + " " + suggestion.city + " " + suggestion.state + " " + suggestion.zipcode
                suggestion_list.append(address)

            # Set completer object and connect it to the lineEdit
            self.autocomplete_model = QStandardItemModel()
            for text in suggestion_list:
                self.autocomplete_model.appendRow(QStandardItem(text))

            self.completer.setModel(self.autocomplete_model)
            self.dlg.single_address_lookup.setCompleter(self.completer)

        else:
            # self.iface.messageBar().pushMessage("We selected an address: ", "but it did not contain entries", level=Qgis.Critical, duration=6)
            return
    
    def set_address(self, candidate):
        address = ''
        if candidate.components.primary_number is not None:
            address = address + candidate.components.primary_number + ' '
        if candidate.components.street_predirection is not None:
            address = address + candidate.components.street_predirection + ' '
        if candidate.components.street_name is not None:
            address = address + candidate.components.street_name + ' '
        if candidate.components.street_postdirection is not None:
            address = address + candidate.components.street_postdirection + ' '
        
        return address
    
    def resize_dialog(self):
        if self.dlg.tabWidget.currentIndex() == 0:
            self.dlg.resize(623,614)
        else:
            self.dlg.resize(586,477)
    
    def add_csv(self):
        if len(self.dlg.csv_file.filePath()) != 0 and self.dlg.batch_address.currentText != '': # This is so if they have a new csv it will reset the drop downs
            self.dlg.id_box.setChecked(False)
            self.dlg.batch_id.clear()
            self.dlg.batch_address.clear()
            self.dlg.batch_city.clear()
            self.dlg.batch_state.clear()
            self.dlg.batch_zip.clear()
            self.dlg.batch_point_label.clear()


        if len(self.dlg.csv_file.filePath()) == 0:
            self.iface.messageBar().pushMessage("Error: ", "Please select a file path", level=Qgis.Critical, duration=6)
            return 
        if len(self.dlg.batch_address.currentText()) > 0:
            self.reset_csv
        
        df = pd.read_csv(self.dlg.csv_file.filePath())
        
        fields = df.columns.values.tolist()

        # TODO: I feel like we should be able to do this in a better manner
        self.dlg.batch_address.addItems(fields)
        self.dlg.batch_city.addItems(fields)
        self.dlg.batch_state.addItems(fields)
        self.dlg.batch_zip.addItems(fields)
        self.dlg.batch_id.addItems(fields)
        fields.insert(0,"None")
        self.dlg.batch_point_label.addItems(fields)

    def enable_id_box(self):
        if len(self.dlg.csv_file.filePath()) == 0:
            self.iface.messageBar().pushMessage("Error: ", "Please select a file path", level=Qgis.Critical, duration=6)
            self.dlg.id_box.setChecked(False)
            return 
        if self.dlg.id_box.isChecked():

            self.dlg.batch_id.setEnabled(True)
        else:
            self.dlg.batch_id.setDisabled(True)
    
    def reset_csv(self):

        self.dlg.csv_file.setFilePath('')
        
        self.dlg.id_box.setChecked(False)
        self.dlg.batch_id.clear()
        self.dlg.batch_address.clear()
        self.dlg.batch_city.clear()
        self.dlg.batch_state.clear()
        self.dlg.batch_zip.clear()
        self.dlg.batch_point_label.clear()

    def handle_success(self, result):
        if Utils.is_valid(result):
            return "valid_address"
        if Utils.is_invalid(result):
            return "invalid_address"
        if Utils.is_missing_secondary(result):
            return "missing_secondary"
        if Utils.is_ambiguous(result):
            return "ambiguous_address"
        return "MAJOR ERROR"

    def output_csv(self, layer_out):
        if self.dlg.csv_file_output.filePath() == '':
            self.iface.messageBar().pushMessage("Error: ", "Please select a folder path", level=Qgis.Critical, duration=6)
            return 

        # TODO: check for .csv on the end 
        folder_path = self.dlg.csv_file_output.filePath()
        if folder_path[-4:] != '.csv': 
            file_path = folder_path + '.csv'

        # TODO: send the layer as parameter?

        # this grabs the field names...
        fields = [field.name() for field in layer_out.fields()] # fields on the selected layer
        
        # FIXME: currently it is just saving the csv file
        with open(file_path, 'a') as name:
            wr = csv.writer(name, quoting=csv.QUOTE_ALL)
            wr.writerow(fields)

            features = layer_out.getFeatures()
            for feature in features:
                attrs = feature.attributes()
                wr.writerow(attrs)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SmartyDialog()
            self.dlg.resize(586, 477)

            # Create a global settings variable         
            settings = QtCore.QSettings()

            # Set the global variables to the text of the auth_id and auth_token
            self.dlg.auth_id.setText(settings.value('auth_id'))
            self.dlg.auth_token.setText(settings.value('auth_token'))

            # Disable sections of dialogue box
            if len(self.dlg.auth_id.text()) == 0:
                self.dlg.frame.setDisabled(True)
            self.dlg.add_csv.setDisabled(True)
            self.dlg.batch_id.setDisabled(True)
            self.dlg.id_box.stateChanged.connect(self.enable_id_box) # I THINK THIS IS CREATING DUPLICATE ROWS IN THE COLUMNS
                
            # Listen for clicked buttons
            self.dlg.single_lookup.clicked.connect(self.smarty_single)
            self.dlg.batch_button.clicked.connect(self.smarty_batch)
            self.dlg.smarty_link_2.clicked.connect(self.smarty_geo_link)
            self.dlg.smarty_link_help.clicked.connect(self.smarty_home_link)
            self.dlg.meta_data.clicked.connect(self.meta_resize) # TODO: if the state changes then do something?
            self.dlg.new_layer_radio.clicked.connect(self.show_new_layer)
            self.dlg.existing_layer_radio.clicked.connect(self.show_existing_layer)
            self.dlg.reset_csv.clicked.connect(self.reset_csv)
            self.dlg.add_csv.clicked.connect(self.add_csv)
            # self.dlg.existing_layer_radio_batch.clicked.connect(self.show_existing_layer_batch)
            # self.dlg.new_layer_radio_batch.clicked.connect(self.show_new_layer_batch)
            # TODO: put the output_csv --> in the batch lookup

            if self.dlg.csv_file.fileChanged: # I DON'T THINK THIS IS DOING ANYTHING
                self.dlg.add_csv.setEnabled(True) #TODO: DISABLE BUTTONS UNTIL CSV IS CHOSEN - THEN MAYBE CONSIDER DOING ERROR HANDLING

            # Add authentication information
            self.dlg.add_tokens.clicked.connect(self.add_tokens) # TODO: IF THE TOKENS ARE STORED THAN ENABLE THE BOX?

            # Fill drop downs
            self.refresh_layers()
            self.fill_symbols()

            # Set correct visibility
            self.dlg.meta_data_results.setVisible(False)
            self.dlg.results.setVisible(False)
            self.dlg.stacked_widget.setVisible(False)
            # self.dlg.stacked_widget_batch.setVisible(False)

            # wait for user to make a selection
            # self.completer.activated.connect(self.autocomplete_apt)
            # Autocompleter listener
            self.dlg.single_address_lookup.textChanged.connect(self.autocomplete)
            
            # Resize Dialog box for batch lookups
            self.dlg.tabWidget.tabBarClicked.connect(self.resize_dialog)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        
        # TODO: I am not sure this is needed?
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
